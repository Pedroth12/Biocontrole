---
title: "Biocontrole de Ferrugem Asi√°tica da soja"
format: html
editor: visual
setup: |
    options(repos = c(CRAN = "https://cloud.r-project.org/"))
---

# O projeto

A ferrugem asi√°tica da soja, causada pelo fungo biotr√≥fico *Phakopsora pachyrhizi*, √© uma das doen√ßas mais severas que acometem a cultura da soja no Brasil e no mundo, resultando em perdas significativas de produtividade. O controle qu√≠mico, baseado em fungicidas multiss√≠tios e s√≠tio-espec√≠ficos, tem sido a principal estrat√©gia adotada, mas enfrenta limita√ß√µes crescentes devido √† evolu√ß√£o da resist√™ncia f√∫ngica e ao elevado custo de aplica√ß√£o.

O controle biol√≥gico, por sua vez, ainda √© pouco explorado e apresenta resultados inconsistentes em campo, refletindo lacunas no conhecimento sobre os agentes e suas intera√ß√µes ecol√≥gicas. Entre as alternativas promissoras, destaca-se a explora√ß√£o de **fungos hiperparasitas** , microrganismos capazes de parasitar outros parasitas, como potenciais agentes de biocontrole. Embora estudos nessa √°rea sejam escassos, os hiperparasitas representam uma via inovadora para o manejo sustent√°vel da ferrugem asi√°tica, especialmente frente ao esgotamento das estrat√©gias convencionais.

Neste estudo, foi avaliada a progress√£o da ferrugem asi√°tica da soja em condi√ß√µes controladas, visando comparar diferentes estrat√©gias de manejo. Foram testados sete isolados de fungos potencialmente hiperparasitas, al√©m de um fungicida qu√≠mico de refer√™ncia e dois produtos biol√≥gicos √† base de *Bacillus* spp. Um tratamento controle negativo, sem aplica√ß√£o de agentes, tamb√©m foi inclu√≠do para efeito comparativo. A severidade da doen√ßa foi quantificada utilizando-se uma escala diagram√°tica padronizada, conforme proposto por Franceschi et al. (2020), que proporciona maior acur√°cia na estimativa dos sintomas e otimiza o uso de recursos experimentais. A proposta central foi investigar o potencial de isolados f√∫ngicos como agentes de biocontrole da ferrugem, em compara√ß√£o √†s estrat√©gias convencionais de controle qu√≠mico e biol√≥gico dispon√≠veis no mercado.

![](images/clipboard-54391932.png)

# Explora√ß√£o inicial de dados

## Gr√°fico √∫nico

```{r}
# Carregar os pacotes necess√°rios
library(readxl)
library(ggplot2)
library(dplyr)

# Importar os dados
dados <- read_excel("Trabalho final Emerson.xlsx", sheet = "Planilha1")

# Resumir os dados: calcular a m√©dia da severidade por tratamento e dia
resumo <- dados %>%
  group_by(Tratamento, Dia) %>%
  summarise(Severidade_media = mean(Severidade, na.rm = TRUE)) %>%
  ungroup()

# Criar o gr√°fico
ggplot(resumo, aes(x = Dia, y = Severidade_media, color = Tratamento)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  labs(
    title = "Severidade da Doen√ßa ao Longo do Tempo",
    x = "Dias ap√≥s Inocula√ß√£o",
    y = "Severidade M√©dia (%)",
    color = "Tratamento"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title = element_text(size = 12),
    legend.position = "right"
  )

```

## Gr√°fico individual

```{r}

# Criar o gr√°fico facetado
ggplot(resumo, aes(x = Dia, y = Severidade_media)) +
  geom_line(color = "steelblue", size = 1) +
  geom_point(color = "steelblue", size = 2) +
  facet_wrap(~ Tratamento) +
  labs(
    title = "Progresso da Severidade da Doen√ßa por Tratamento",
    x = "Dias ap√≥s Inocula√ß√£o",
    y = "Severidade M√©dia (%)"
  ) +
  theme_minimal() +
  theme(
    strip.text = element_text(face = "bold", size = 12),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title = element_text(size = 12)
  )

```

# Calculando √Årea Abaixo da Curva de Progresso da Doen√ßa (AACPD)

```{r}
library(tidyverse)
library(pracma)
library(lme4)
library(lmerTest)  # para obten√ß√£o de p‚Äëvalue
# Calcular AACPD por Planta / Trif√≥lio / Fol√≠olo / Avaliador
aacpd_result <- dados %>%
  group_by(Tratamento, Planta, Trifolio, Foliolo, Avaliador) %>%
  summarise(
    AACPD = trapz(Dia, Severidade),
    .groups = "drop"
  )

modelo_aacpd <- lmer(
  AACPD ~ Tratamento + (1 | Planta/Trifolio/Foliolo/Avaliador),
  data = aacpd_result
)

# Exibir resultados
summary(modelo_aacpd)
anova(modelo_aacpd)
# Diagn√≥stico dos res√≠duos
plot(modelo_aacpd)
qqnorm(resid(modelo_aacpd)); qqline(resid(modelo_aacpd))
shapiro.test(resid(modelo_aacpd))
library(car)
leveneTest(AACPD ~ Tratamento, data = aacpd_result)
```

# Transforma√ß√µes

## Transforma√ß√£o log

```{r}
library(tidyverse)
library(pracma)
library(lme4)
library(lmerTest)
library(car)

# Calcular AACPD por unidade experimental
aacpd_result <- dados %>%
  group_by(Tratamento, Planta, Trifolio, Foliolo, Avaliador) %>%
  summarise(
    AACPD = trapz(Dia, Severidade),
    .groups = "drop"
  ) %>%
  mutate(
    AACPD_log = log1p(AACPD)  # transforma√ß√£o log(1 + x)
  )

# Modelo com AACPD transformado
modelo_log <- lmer(
  AACPD_log ~ Tratamento + (1 | Planta/Trifolio/Foliolo/Avaliador),
  data = aacpd_result
)

# Verificar resultados
summary(modelo_log)
anova(modelo_log)

# Diagn√≥stico dos res√≠duos transformados
plot(modelo_log)
qqnorm(resid(modelo_log)); qqline(resid(modelo_log))
shapiro.test(resid(modelo_log))
leveneTest(AACPD_log ~ Tratamento, data = aacpd_result)
```

## Transforma√ß√£o Box-Cox

```{r}
# Pacotes necess√°rios
library(tidyverse)
library(pracma)
library(lme4)
library(lmerTest)
library(MASS)
library(car)

# 1. Calcular AACPD por unidade experimental
aacpd_result <- dados %>%
  group_by(Tratamento, Planta, Trifolio, Foliolo, Avaliador) %>%
  summarise(
    AACPD = trapz(Dia, Severidade),
    .groups = "drop"
  )

# 2. Estimar lambda ideal com Box-Cox (usando modelo linear simples)
modelo_lm <- lm(AACPD ~ Tratamento, data = aacpd_result)

boxcox_result <- boxcox(modelo_lm, lambda = seq(-2, 2, 0.1))

# 3. Obter lambda √≥timo
lambda_otimo <- boxcox_result$x[which.max(boxcox_result$y)]
print(paste("Melhor lambda =", round(lambda_otimo, 2)))

# 4. Aplicar a transforma√ß√£o Box-Cox manualmente
aacpd_result <- aacpd_result %>%
  mutate(
    AACPD_boxcox = if (abs(lambda_otimo) < 1e-4) log(AACPD) else (AACPD^lambda_otimo - 1) / lambda_otimo
  )

# 5. Ajustar modelo misto com a vari√°vel transformada
modelo_boxcox <- lmer(
  AACPD_boxcox ~ Tratamento + (1 | Planta/Trifolio/Foliolo/Avaliador),
  data = aacpd_result
)

# 6. An√°lise dos resultados
summary(modelo_boxcox)
anova(modelo_boxcox)

# 7. Diagn√≥stico dos res√≠duos
plot(modelo_boxcox)
qqnorm(resid(modelo_boxcox)); qqline(resid(modelo_boxcox))
shapiro.test(resid(modelo_boxcox))
leveneTest(AACPD_boxcox ~ Tratamento, data = aacpd_result)

```

## Transforma√ß√£o SQRT

```{r}
# Carregar pacotes necess√°rios
library(tidyverse)
library(pracma)
library(lme4)
library(lmerTest)
library(car)

# 1. Calcular AACPD por unidade experimental
aacpd_result <- dados %>%
  group_by(Tratamento, Planta, Trifolio, Foliolo, Avaliador) %>%
  summarise(
    AACPD = trapz(Dia, Severidade),
    .groups = "drop"
  ) %>%
  mutate(
    AACPD_sqrt = sqrt(AACPD)  # Aplicando raiz quadrada
  )

# 2. Ajustar modelo misto com vari√°vel transformada
modelo_sqrt <- lmer(
  AACPD_sqrt ~ Tratamento + (1 | Planta/Trifolio/Foliolo/Avaliador),
  data = aacpd_result
)

# 3. An√°lise dos resultados
summary(modelo_sqrt)
anova(modelo_sqrt)

# 4. Diagn√≥stico dos res√≠duos
plot(modelo_sqrt)  # Res√≠duos vs valores ajustados
qqnorm(resid(modelo_sqrt)); qqline(resid(modelo_sqrt))  # QQ-plot
shapiro.test(resid(modelo_sqrt))  # Teste de normalidade dos res√≠duos

# 5. Teste de homogeneidade de vari√¢ncia
leveneTest(AACPD_sqrt ~ Tratamento, data = aacpd_result)

```

# Modelo misto

```{r}
# Pacotes necess√°rios
library(tidyverse)
library(pracma)
library(lme4)
library(lmerTest)
library(pbkrtest)

# 1. Calcular AACPD (sem transforma√ß√£o)
aacpd_result <- dados %>%
  group_by(Tratamento, Planta, Trifolio, Foliolo, Avaliador) %>%
  summarise(
    AACPD = trapz(Dia, Severidade),
    .groups = "drop"
  )

# 2. Ajustar o modelo completo (com tratamento)
modelo_completo <- lmer(
  AACPD ~ Tratamento + (1 | Planta/Trifolio/Foliolo/Avaliador),
  data = aacpd_result,
  REML = FALSE  # necess√°rio para compara√ß√£o de modelos
)

# 3. Ajustar o modelo nulo (sem tratamento)
modelo_nulo <- lmer(
  AACPD ~ 1 + (1 | Planta/Trifolio/Foliolo/Avaliador),
  data = aacpd_result,
  REML = FALSE
)

# 4. Compara√ß√£o robusta por bootstrap
comparacao_robusta <- PBmodcomp(modelo_completo, modelo_nulo, nsim = 1000)
print(comparacao_robusta)


```

# Ranking dos tratamentos

```{r}
# 1. Ajustar modelo misto (se ainda n√£o tiver feito)
modelo_completo <- lmer(
  AACPD ~ Tratamento + (1 | Planta/Trifolio/Foliolo/Avaliador),
  data = aacpd_result,
  REML = TRUE  # pode voltar a usar REML aqui para melhores estimativas
)

# 2. Carregar o pacote de m√©dias marginais estimadas
library(emmeans)

# 3. Obter as m√©dias estimadas por tratamento (ajustadas pelo modelo)
medias <- emmeans(modelo_completo, ~ Tratamento)

# 4. Compara√ß√µes m√∫ltiplas com ajuste de Tukey
comparacoes <- pairs(medias, adjust = "tukey")
print(comparacoes)

# 5. Ranqueamento dos tratamentos
ranking <- multcomp::cld(medias, Letters = letters)  # gera grupos de letras
print(ranking)

```

# Gr√°fico comparando os tratamentos

```{r}
library(emmeans)
library(multcomp)
library(ggplot2)
library(dplyr)
library(stringr)
# 1. Obter m√©dias ajustadas do modelo
medias <- emmeans(modelo_completo, ~ Tratamento)

# 2. Compara√ß√µes com Tukey + letras de signific√¢ncia
letras <- cld(medias, Letters = letters, adjust = "tukey")

# 3. Remover espa√ßos das letras
letras$.group <- gsub(" ", "", letras$.group)

# 4. Renomear tratamentos corretamente
letras$Tratamento <- letras$Tratamento %>%
  str_replace("(?i)isola[dt]o\\s*", "Iso. ") %>%
  str_replace("(?i)produto\\s*", "Prod. ") %>%
  str_replace("(?i)controle", "Cont.")
# 5. Ordenar por AACPD (emmean) e fixar ordem como fator
letras <- letras %>%
  arrange(emmean) %>%
  mutate(Tratamento = factor(Tratamento, levels = Tratamento))

# 6. Plot com nomes e ordem corrigidos
ggplot(letras, aes(x = Tratamento, y = emmean)) +
  geom_col(fill = "#4682B4", width = 0.7) +
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2) +
  geom_text(aes(label = .group), vjust = -0.5, size = 5) +
  labs(
    title = "AACPD ajustado por tratamento",
    y = "AACPD (√°rea abaixo da curva)",
    x = "Tratamento"
  ) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

# Modelo Generalziado - TESTE DE AJUSTE VIA K-S

```{r}
library(MASS)   # Para fitdistr
library(stats)

# Vetor de resposta
x <- aacpd_result$AACPD

# 1. Normal
ks.test(x, "pnorm", mean = mean(x), sd = sd(x))

# 2. Gamma
gamma_fit <- fitdistr(x, "gamma")
ks.test(x, "pgamma", shape = gamma_fit$estimate["shape"], rate = gamma_fit$estimate["rate"])

# 3. Log-Normal
ks.test(x, "plnorm", meanlog = mean(log(x)), sdlog = sd(log(x)))

# 4. Beta ‚Äî somente se seus dados estiverem entre 0 e 1
# Primeiro normaliza se necess√°rio
x_beta <- (x - min(x) + 0.001) / (max(x) - min(x) + 0.002)  # para garantir que caia entre (0,1)
beta_fit <- fitdistr(x_beta, dbeta, start = list(shape1 = 1, shape2 = 1))
ks.test(x_beta, "pbeta", shape1 = beta_fit$estimate["shape1"], shape2 = beta_fit$estimate["shape2"])

```

# Modelo Generalziado

```{r}
# Pacotes
library(DHARMa)
library(readxl)
library(pracma)
library(emmeans)
library(multcompView)
library(multcomp)
library(stringr)

# 1. Carregar os dados
dados <- read_excel("Trabalho final Emerson.xlsx", sheet = "Planilha1")

# 2. Calcular AACPD por unidade experimental
aacpd_result <- dados %>%
  arrange(Planta, Trifolio, Foliolo, Avaliador, Tratamento, Dia) %>%
  group_by(Planta, Trifolio, Foliolo, Avaliador, Tratamento) %>%
  summarise(
    AACPD = trapz(Dia, Severidade),
    .groups = "drop"
  )

# 3. Ajustar valores zero (GLMM Gamma n√£o aceita zeros)
aacpd_result <- aacpd_result %>%
  mutate(AACPD_adj = AACPD + 0.01)

# 4. Modelo misto com distribui√ß√£o Gamma
modelo_glmm <- glmer(
  AACPD_adj ~ Tratamento + (1 | Planta/Trifolio/Foliolo/Avaliador),
  data = aacpd_result,
  family = Gamma(link = "log")
)

# 5. Diagn√≥stico
summary(modelo_glmm)
res_sim <- simulateResiduals(modelo_glmm)
plot(res_sim)

# 6. M√©dias ajustadas e letras
medias <- emmeans(modelo_glmm, ~ Tratamento, type = "response")
letras <- cld(medias, Letters = letters, adjust = "tukey")
letras$.group <- gsub(" ", "", letras$.group)

# 7. Renomear tratamentos
letras$Tratamento <- letras$Tratamento %>%
  str_replace("(?i)isola[dt]o\\s*", "Iso. ") %>%
  str_replace("(?i)produto\\s*", "Prod. ") %>%
  str_replace("(?i)controle", "Cont.")

# 8. Organizar para gr√°fico
letras_df <- letras[, c("Tratamento", "response", "SE", ".group")]

# Reordena com base nos valores m√©dios
ordem <- letras_df$Tratamento[order(letras_df$response)]
letras_df$Tratamento <- factor(letras_df$Tratamento, levels = ordem)

# 9. Gr√°fico
ggplot(letras_df, aes(x = Tratamento, y = response)) +
  geom_col(fill = "#66c2a5", width = 0.7) +
  geom_errorbar(aes(ymin = response - SE, ymax = response + SE), width = 0.2) +
  geom_text(aes(label = .group), vjust = -0.5, fontface = "bold", size = 5) +
  labs(
    title = "AACPD dos tratamentos",
    x = "Tratamentos",
    y = "AACPD"
  ) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

# AACPD em 28 dias

```{r}
# -----------------------------
# üì¶ Pacotes
# -----------------------------
library(DHARMa)
library(readxl)
library(tidyverse)
library(pracma)
library(lme4)
library(emmeans)
library(multcompView)
library(multcomp)
library(stringr)

# -----------------------------
# üì• 1. Carregar os dados
# -----------------------------
dados <- read_excel("Trabalho final Emerson.xlsx", sheet = "Planilha1")

# -----------------------------
# üßπ 2. Filtrar at√© o dia 28
# -----------------------------
dados_filtrados_28 <- dados %>%
  filter(Dia <= 28)

# -----------------------------
# üìä 3. Calcular AACPD por unidade experimental
# -----------------------------
aacpd_result_28 <- dados_filtrados_28 %>%
  arrange(Planta, Trifolio, Foliolo, Avaliador, Tratamento, Dia) %>%
  group_by(Planta, Trifolio, Foliolo, Avaliador, Tratamento) %>%
  summarise(
    AACPD = trapz(Dia, Severidade),
    .groups = "drop"
  )

# -----------------------------
# ‚ö†Ô∏è 4. Ajustar valores zero (GLMM Gamma n√£o aceita zeros)
# -----------------------------
aacpd_result_28 <- aacpd_result_28 %>%
  mutate(AACPD_adj_28 = AACPD + 0.01)

# -----------------------------
# üèóÔ∏è 5. Modelo misto com distribui√ß√£o Gamma
# -----------------------------
modelo_glmm_28 <- glmer(
  AACPD_adj_28 ~ Tratamento + (1 | Planta/Trifolio/Foliolo/Avaliador),
  data = aacpd_result_28,
  family = Gamma(link = "log")
)

# -----------------------------
# üß™ 6. Diagn√≥stico de res√≠duos
# -----------------------------
summary(modelo_glmm_28)
res_sim_28 <- simulateResiduals(modelo_glmm_28)
plot(res_sim_28)

# -----------------------------
# üìä 7. M√©dias ajustadas e letras de signific√¢ncia
# -----------------------------
medias_28 <- emmeans(modelo_glmm_28, ~ Tratamento, type = "response")
letras_28 <- cld(medias_28, Letters = letters, adjust = "tukey")
letras_28$.group <- gsub(" ", "", letras_28$.group)

# Renomear tratamentos para gr√°fico
letras_28$Tratamento <- letras_28$Tratamento %>%
  str_replace("(?i)isola[dt]o\\s*", "Iso. ") %>%
  str_replace("(?i)produto\\s*", "Prod. ") %>%
  str_replace("(?i)controle", "Cont.")

# -----------------------------
# üì¶ 8. Organizar para gr√°fico
# -----------------------------
letras_df_28 <- letras_28[, c("Tratamento", "response", "SE", ".group")]

# Reordenar fatores para o gr√°fico
ordem_28 <- letras_df_28$Tratamento[order(letras_df_28$response)]
letras_df_28$Tratamento <- factor(letras_df_28$Tratamento, levels = ordem_28)

# -----------------------------
# üé® 9. Gr√°fico final
# -----------------------------
ggplot(letras_df_28, aes(x = Tratamento, y = response)) +
  geom_col(fill = "#CC5500", width = 0.7) +
  geom_errorbar(aes(ymin = response - SE, ymax = response + SE), width = 0.2) +
  geom_text(aes(label = .group), vjust = -0.5, fontface = "bold", size = 5) +
  labs(
    title = "AACPD dos tratamentos (at√© 28 dias)",
    x = "Tratamentos",
    y = "AACPD"
  ) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))



```

# AACPD 35 dias

```{r}
# -----------------------------
# üì¶ Pacotes
# -----------------------------
library(DHARMa)
library(readxl)
library(tidyverse)
library(pracma)
library(lme4)
library(emmeans)
library(multcompView)
library(multcomp)
library(stringr)

# -----------------------------
# üì• 1. Carregar os dados
# -----------------------------
dados <- read_excel("Trabalho final Emerson.xlsx", sheet = "Planilha1")

# -----------------------------
# üßπ 2. Filtrar at√© o dia 35
# -----------------------------
dados_filtrados_35 <- dados %>%
  filter(Dia <= 35)

# -----------------------------
# üìä 3. Calcular AACPD por unidade experimental
# -----------------------------
aacpd_result_35 <- dados_filtrados_35 %>%
  arrange(Planta, Trifolio, Foliolo, Avaliador, Tratamento, Dia) %>%
  group_by(Planta, Trifolio, Foliolo, Avaliador, Tratamento) %>%
  summarise(
    AACPD = trapz(Dia, Severidade),
    .groups = "drop"
  )

# -----------------------------
# ‚ö†Ô∏è 4. Ajustar valores zero (GLMM Gamma n√£o aceita zeros)
# -----------------------------
aacpd_result_35 <- aacpd_result_35 %>%
  mutate(AACPD_adj_35 = AACPD + 0.01)

# -----------------------------
# üèóÔ∏è 5. Modelo misto com distribui√ß√£o Gamma
# -----------------------------
modelo_glmm_35 <- glmer(
  AACPD_adj_35 ~ Tratamento + (1 | Planta/Trifolio/Foliolo/Avaliador),
  data = aacpd_result_35,
  family = Gamma(link = "log")
)

# -----------------------------
# üß™ 6. Diagn√≥stico de res√≠duos
# -----------------------------
summary(modelo_glmm_35)
res_sim_35 <- simulateResiduals(modelo_glmm_35)
plot(res_sim_35)

# -----------------------------
# üìä 7. M√©dias ajustadas e letras de signific√¢ncia
# -----------------------------
medias_35 <- emmeans(modelo_glmm_35, ~ Tratamento, type = "response")
letras_35 <- cld(medias_35, Letters = letters, adjust = "tukey")
letras_35$.group <- gsub(" ", "", letras_35$.group)

# Renomear tratamentos para gr√°fico
letras_35$Tratamento <- letras_35$Tratamento %>%
  str_replace("(?i)isola[dt]o\\s*", "Iso. ") %>%
  str_replace("(?i)produto\\s*", "Prod. ") %>%
  str_replace("(?i)controle", "Cont.")

# -----------------------------
# üì¶ 8. Organizar para gr√°fico
# -----------------------------
letras_df_35 <- letras_35[, c("Tratamento", "response", "SE", ".group")]

# Reordenar fatores para o gr√°fico
ordem_35 <- letras_df_35$Tratamento[order(letras_df_35$response)]
letras_df_35$Tratamento <- factor(letras_df_35$Tratamento, levels = ordem_35)

# -----------------------------
# üé® 9. Gr√°fico final
# -----------------------------
ggplot(letras_df_35, aes(x = Tratamento, y = response)) +
  geom_col(fill = "#BC8F8F", width = 0.7) +
  geom_errorbar(aes(ymin = response - SE, ymax = response + SE), width = 0.2) +
  geom_text(aes(label = .group), vjust = -0.5, fontface = "bold", size = 5) +
  labs(
    title = "AACPD dos tratamentos (at√© 35 dias)",
    x = "Tratamentos",
    y = "AACPD"
  ) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
